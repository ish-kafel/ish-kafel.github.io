<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Nonogram Solver</title>
  <style>
    body {
      /*width: 500px;*/
      /*line-height: 9.1px;*/
    }

    div {
      height: 260px;
      font-size: 12px;
      /*overflow: scroll;*/
    }

    #rr {
      width: 100px;
    }

    #cc {
      width: 100px;
      -moz-writing-mode: vertical-lr;
      -webkit-writing-mode: vertical-lr;
      writing-mode: vertical-lr;
    }
  </style>
</head>

<body>
  <textarea name="" id="rr" placeholder="行数组" rows="15" cols="40">5
1 5
3 1
2 2
3 3
5 4
2 4 2
1 1 2
1 4 1
4 7
4 2 2
2 2 2 1
1 1 1 1
1 1 1 1
1 1 1</textarea>
  <textarea name="" id="cc" placeholder="列数组" rows="15" cols="40">1 3
2 2 1
1 5
3 2
1 4
1 1 3 3
1 1 1 1
1 2 2
1 1 1 3
1 1 1 3 1
3 2 2
5 1
1 7
2 4 2 1
1 3</textarea><br><br>
  <button id="btn">求解</button><br><br>
  <div id="solution"></div>
  <script>
    const log = console.log.bind(console)
    const write = function(msg) {
      //document.write
      progstr += msg + '<br><br>'
    }
    const spreg = / +/
    let correct, cross, unsettled, updatecorrect, updatecross, progstr, s, rows, cols, rowsset, colsset, solverow, solvecol, solve, update, n, save, mapp

    function check() {
      if (rows.length !== cols.length) return '行列数不一致'
      //if (rows.length !== s) return '行数不为' + s
      //if (cols.length !== s) return '列数不为' + s
      for (let i = 0; i < rows.length; i++) {
        if (rows[i].reduce((p, c) => p + c) + rows[i].length - 1 > s) return '第' + (i + 1) + '行结果超过' + s
      }
      for (let i = 0; i < cols.length; i++) {
        if (cols[i].reduce((p, c) => p + c) + cols[i].length - 1 > s) return '第' + (i + 1) + '列结果超过' + s
      }
      if (rows.flat().reduce((p, c) => p + c) !== cols.flat().reduce((p, c) => p + c)) {
        return '行列求和不一致'
      }
      return false
    }

    function gen(arr, t) {
      arr = arr.slice()
      let res = [new Array(t).fill(cross)]
      let tmp = []
      let len = arr.length
      while (arr[0]) {
        while (res[0]) {
          let start = res[0].lastIndexOf(correct) + 1 + (arr.length !== len)
          for (let i = start; i <= t - arr[0]; i++) {
            tmp.push(res[0].toSpliced(i, arr[0], ...new Array(arr[0]).fill(correct)))
          }
          res.shift()
        }
        arr.shift()
        res.push(...tmp)
        tmp = []
      }
      return res
    }

    function merge(arr) {
      if (arr.length === 1) return arr[0].slice()
      let base = arr[0].slice()
      for (let i = 1; i < arr.length; i++) {
        for (let j = 0; j < arr[i].length; j++) {
          if (base[j] !== arr[i][j]) {
            base[j] = 0
          }
        }
      }
      return base
    }

    function writesolve() {
      let arr = solve.map(e => e.map(e => mapp[e]))
      for (let u of update) {
        arr[u[0]][u[1]] = u[3] == correct ? updatecorrect : u[3] == cross ? updatecross : ''
      }
      write(arr.map(e => e.join('')).join('<br>'))
    }

    function clone() {
      save = {
        rowsset: rowsset.map(e => e.map(e1 => e1.slice())),
        colsset: colsset.map(e => e.map(e1 => e1.slice())),
        n,
        solve: solve.map(e => e.slice()),
      }
    }

    function load() {
      rowsset = save.rowsset.map(e => e.map(e1 => e1.slice()))
      colsset = save.colsset.map(e => e.map(e1 => e1.slice()))
      n = save.n
      solve = save.solve.map(e => e.slice())
    }

    function ans() {
      while (update.length) {
        write('n=' + n)
        update = []
        solverow = []
        solvecol = []
        for (let i = 0; i < s; i++) {
          solverow.push(merge(rowsset[i]))
        }
        for (let i = 0; i < s; i++) {
          solvecol.push(merge(colsset[i]))
        }
        for (let i = 0; i < s; i++) {
          for (let j = 0; j < s; j++) {
            let r = solverow[i][j]
            let c = solvecol[j][i]
            if (r) {
              if (!c) {
                if (solve[i][j] != r) {
                  update.push([i, j, 1, r])
                  solve[i][j] = r
                }
              } else {
                if (r !== c) return [i, j] //Error
                solve[i][j] = r
              }
            } else if (c) {
              if (solve[i][j] != c) {
                update.push([i, j, 0, c])
                solve[i][j] = c
              }
            }
          }
        }
        for (let u of update) {
          if (u[2] === 0) {
            rowsset[u[0]] = rowsset[u[0]].filter(e => e[u[1]] === u[3])
            if (rowsset[u[0]].length === 0) return [u[0], -1] //Error
          } else if (u[2] === 1) {
            colsset[u[1]] = colsset[u[1]].filter(e => e[u[0]] === u[3])
            if (colsset[u[1]].length === 0) return [-1, u[1]] //Error
          }
        }
        writesolve()
        n++
      }
      return collect()
    }

    function collect() {
      let res = []
      for (let i = 0; i < s; i++) {
        for (let j = 0; j < s; j++) {
          if (!solve[i][j]) res.push([i, j])
        }
      }
      return res
    }

    function assume(x, y) {
      write('n=' + n + ' 假设 ' + [x, y])
      solve[x][y] = correct
      let u = [x, y, , correct]
      update.push(u)
      rowsset[x] = rowsset[x].filter(e => e[y] === correct)
      colsset[y] = colsset[y].filter(e => e[x] === correct)
      writesolve()
      n++
    }

    function queue() {
      let prep = check()
      if (prep) {
        write(prep + ',请检查')
        return
      }
      let collectij = ans()
      if (collectij.length === 0) {
        write('已解决')
        return
      }
      if (!Array.isArray(collectij[0])) {
        write('题目出错，否则无解')
      }
      let i = Math.floor(Math.random() * collectij.length)
      let x, y, re
      clone();
      while (collectij.length) {
        ;
        [x, y] = collectij.splice(i, 1)[0]
        assume(x, y)
        re = ans()
        if (re.length == 0) {
          write('已解决')
          return
        }
        if (Array.isArray(re[0])) {
          i = Math.floor(Math.random() * collectij.length)
          write('无法确定，更换下一个')
        } else {
          //write('无解，在' + re)
          if (re[0] + 1) x = re[0]
          if (re[1] + 1) y = re[1]
          i = collectij.findIndex(e => e[0] == x && e[1] == y)
          if (i === -1) {
            i = Math.floor(Math.random() * collectij.length)
            write('无解，更换下一个')
          } else {
            write('无解，在' + re)
          }
        }
        load()
      }
      write('本题无解')
      //document.body += progstr
      return
    }
    btn.onclick = function() {
      correct = '🟩'
      cross = '❌'
      unsettled = '⬛'
      updatecorrect = '✅'
      updatecross = '❎'
      mapp = { '0': unsettled, [correct]: correct, [cross]: cross, [updatecorrect]: updatecorrect, [updatecross]: updatecross }
      progstr = '<br>'
      rows = rr.value != '' ? (rr.value.split('\n').map(e => e.split(spreg).map(e1 => +e1))) : '3 2.5 1.3 1.2.4.11.5 3.1 3 2.2 4.2 2.4 2.5 2.3 2 2.2 3.6 2'.split('.').map(e => e.split(spreg).map(e1 => +e1))
      cols = cc.value != '' ? (cc.value.split('\n').map(e => e.split(spreg).map(e1 => +e1))) : '1 1.3 3.3 3.3 1 6.1 2 4.3 1.4 1.10.2 7.1 2 1.4 1.4.5 1.2 2 3.1 3'.split('.').map(e => e.split(spreg).map(e1 => +e1))
      s = rows.length
      rowsset = rows.map(e => gen(e, s))
      colsset = cols.map(e => gen(e, s))
      solverow = []
      solvecol = []
      solve = new Array(s).fill(0).map(e => new Array(s).fill(0))
      update = [0]
      n = 1
      save = {}
      queue()
      solution.innerHTML = progstr
    }
  </script>
</body>

</html>
